// _スライス (Slices)_ は、シーケンスに対して
// 配列よりもさらに強力なインターフェースを提供する
// Go の重要なデータ型です。

package main

import (
	"fmt"
	"slices"
)

func main() {

	// 配列とは異なり、スライスは含まれる要素だけで
	// 型が定義されます (要素の数は関係ありません)。
	// 初期化されていないスライスは nil で、長さは 0 です。
	var s []string
	fmt.Println("uninit:", s, s == nil, len(s) == 0)

	// 長さが 0 でない空のスライスを作るには、
	// `make` ビルトイン関数を使います。ここでは、
	// 長さ `3` の `string` のスライスを作っています
	// (ゼロ値で初期化されます)。
	// デフォルトでは、新規作成したスライスの容量は、スライスの
	// 長さと等しくなります。スライスが時間とともに大きくなると
	// 分かっている場合は、 `make` への追加引数として明示的に
	// 容量を指定することができます。
	s = make([]string, 3)
	fmt.Println("emp:", s, "len:", len(s), "cap:", cap(s))

	// 配列と全く同じように値の設定と取得が可能です。
	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println("set:", s)
	fmt.Println("get:", s[2])

	// `len` は期待通りスライスの長さを返します。
	fmt.Println("len:", len(s))

	// これらの基本的な操作に加えて、スライスは
	// 配列よりも便利な操作をサポートします。
	// その 1 つが、1 つ以上の新しい値を含んだ
	// スライスを返す `append` ビルトイン関数です。
	// ただし、 `append` から返される値として
	// 新しいスライス値を受け取るかもしれないことを
	// 許容する必要がある点に注意してください。
	s = append(s, "d")
	s = append(s, "e", "f")
	fmt.Println("apd:", s)

	// スライスは `copy` することもできます。ここでは、
	// `s` と同じ長さの空のスライス `c` を作成し、
	// `s` から `c` へコピーしています。
	c := make([]string, len(s))
	copy(c, s)
	fmt.Println("cpy:", c)

	// スライスは、 `slice[下限:上限]` という記法の
	// "スライス" 演算をサポートします。例えば、これは
	// `s[2]` と `s[3]`, `s[4]` の要素をもつスライスを
	// 取得します。
	l := s[2:5]
	fmt.Println("sl1:", l)

	// これは、 `s[5]` まで (上限は除いて) スライスします。
	l = s[:5]
	fmt.Println("sl2:", l)

	// そしてこれは、 `s[2]` から（下限は含んで）
	// スライスします。
	l = s[2:]
	fmt.Println("sl3:", l)

	// スライスの変数を 1 行で宣言かつ初期化することも
	// できます。
	t := []string{"g", "h", "i"}
	fmt.Println("dcl:", t)

	// `slices` パッケージは多数の便利関数を含んでいます。
	t2 := []string{"g", "h", "i"}
	if slices.Equal(t, t2) {
		fmt.Println("t == t2")
	}

	// スライスを多次元のデータ構造にすることもできます。
	// 多次元配列とは異なり、内側のスライスの長さは
	// 変わりえます。
	twoD := make([][]int, 3)
	for i := 0; i < 3; i++ {
		innerLen := i + 1
		twoD[i] = make([]int, innerLen)
		for j := 0; j < innerLen; j++ {
			twoD[i][j] = i + j
		}
	}
	fmt.Println("2d: ", twoD)
}
